# 11 PRODUCTS

## 11.0 Product Model

1. model 생성
2. 데이터베이스 수정
3. mutation 진행
4. useSWR로 데이터 가져오기

데이터의 길이 설정
String으로 쓰면 prisma에서 varchar로 설정할 것이라는 추측
== MySQL의 normal varchar 같은(191자 제한)

```js
model Product {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     Int
  image      String
  name       String
  prcie      Int
  decription String   @db.MediumText // MEDIUMTEXT 최대 16,666,215, 개의 문자 저장이 가능한 가변 길이 문자형

  @@index([userId])
}

```

[기본 유형 매핑](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#native-types-mapping)
이 필드에 사용해야 하는 기본 데이터베이스 유형을 정의합

[MySQL 기본 데이터베이스 유형](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#mysql)
ex) @db.Text, @db.MediumText, @db.LongText

[MySQL에서 length로 인덱스 길이 구성](https://www.prisma.io/docs/concepts/components/prisma-schema/indexes#configuring-the-length-of-indexes-with-length-mysql)

```js
model Id {
id String @id @db.VarChar(3000)
}
```

[Next.js로 PrismaClient를 인스턴스화하기 위한 모범 사례](https://www.prisma.io/docs/support/help-articles/nextjs-prisma-client-dev-practices)
(+아래 경고를 해결하는 효과적인 방법)
warn(prisma-client) There are already 10 instances of Prisma Client actively running.

### Primsa Client 인스턴스 관리

일 반적으로 Prisma client는 모듈이나 함수등이 실행 될때 새로운 인스턴스 생성.
이는 성능에 영향을 미칠 수 있으며, 개발환경에서 빈번하게 코드를 수정하고 테스트 하는경우에는 더욱 그럼

**development 환경**

- 기본적으로 prisma client인스턴스를 한 번 생성하고 재사용하는 것
- 코드를 실행할때마다 prisma client를 생성하는 것이 않고 기존 인스턴스를 사용해 성능을 향상 시킴

**product 환경**

- prisma client를 단일 인스턴스로 사용하는 것이 아니라 여러 인스턴스를 사용해 확장성을 보장하는 것이 일반적
- product환경에서는 prisma client를 전역변수로 할당하는 것이 아닌 각 인스턴스에 새로운 prisma client 인스턴스를 생성하는 것이 좋음

아래의 코드는 development 환경에서만 prisma client를 전역변수로할당하는 것으로 성능을개선하는 방법
(product 환경에서는 사용하지 않음)

```ts
mport { PrismaClient } from "@prisma/client";

declare global {
  var client: PrismaClient | undefined;
}
const client = global.client || new PrismaClient();

if (process.env.NODE_ENV === "development") global.client = client;

export default client;

```

## 11.1 Upload Form

prisma에서 제공해주는 타입기능!

```ts
//pages/products/upload.tsx

import { Product } from "@prisma/client";
interface UploadProductMutation {
  ok: boolean;
  product: Product;
}
```

realation관계는 connect로 작성

```ts
async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseType>
) {
  const {
    body: { name, price, description },
    session: { user },
  } = req;
  const product = await client.product.create({
    data: {
      name,
      price: +price,
      description,
      image: "xx",
      user: {
        //user은 userId 를 사용해서 User의 데이터와 연결시킴
        connect: {
          id: user?.id, // 세션에서 가져옴 현재 로그인한 유저의 정보
        },
      },
    },
  });
  res.json({
    ok: true,
    product,
  });
}
```

## 11.2 Upload API

REST API 을 생성하기위해 기존의 type을 배열로 변경

- 같은 endpoint 에서 다른 Method를 쓰는것을 목적
- `libs/server/withHandler.ts` 파일 : ['GET','POST']로 둘중에 하나를 보내는 것을 전달
- `pages/api/products/index.ts` 파일 : api 코드상에서 method에 따라 분기처리함

## 11.3 See Products

## 11.4 Product Detail

프론트엔드 : `router.query`

```ts
const ItemDetail: NextPage = () => {
    const router = useRouter();
    const { data, error } = useSWR(
    router.query.id ?`/api/products/${router.query.id}` : null
    );
```

백엔드 : `req.query`

내가 원하는 정보를 쏙쏙쏙 골라내어 가져올수있음

- 아래에서는 id, name, avatar 선택
- 모두 가져오면 생성날짜, 업데이트날짜 같은것도 모두 가져오게됨

```ts
async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseType>
) {
  const id = req.query.id; //백엔드에서도 쿼리값 가져올수있음!
  const product = await client.product.findUnique({
    where: {
      id: Number(id),
    },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          avatar: true,
        },
      },
    },
  });
  res.json({ ok: true, product });
}
```

## 11.5 Related Products

## 11.6 Favorite Products

## 11.7 Favorite Products part Two

## 11.8 Bound Mutations

## 11.9 Unbound Mutations

## 11.10 Counting Relationships
